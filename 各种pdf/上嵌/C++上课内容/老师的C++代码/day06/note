1.类与类之间的关系（设计角度，不是语法上的关系！！！）

	1.继承
			class A{};
			class B:public A{};

	2.组合	一个类的对象是另外一个类的成员

			class A{};
			class B{A a;};

	3.依赖	一个类的对象(指针或引用)在另外一个类中作为局部变量使用
			class A{};
			class B{void show( A &a)};
			Or
			class B{void show(){ A a;}};

2.C++软件基本框架的搭建原则（选学）

	1.表示层  -------- 界面及其相关类

				这些类的基本功能：1.数据的显示
						           2.数据的传递
							   3.根据不同的数据作出不同显示
							   4.界面布局/美化

			例如：你设计了一个用户登录界面类

				在这个类中，你不要把 

						验证用户是否存在
						验证密码是否正确
						。。。。。等

				业务逻辑的代码放在这些类中

				class MainUI
				{
					void showSuccessUI();
					void showFailure();
					void getData()
					{
						string  szName = getXXX();
						string  szPasswd = getXXX();

					// 验证类的成员函数一般都是静态的
					int nRes = Valid::CheckID(szName,szPasswd)

						switch(nRes)
						{
						case 0 :  showSuccessUI();break;
						case 1 :  showFailure();break;
						}

					}
				}

	2.业务逻辑层  ------- 功能的实现，错误的处理 的 一系列类

		class Valid
		{
			string m_name;
			string m_passwd;

			vector  m_v;		//  装载从文件中读取的 用户名和密码
		public:
			// 这个函数不读写文件
			static int GetVector() 
			{

				// 从文件中读取的 用户名和密码
				vector v  = FileOperator::Getvector();
				if() //判断V是否有内容
					m_v = v;
				else
					// 错误处理
				

			}
		
			static int CheckName()
			{
				// 遍历v
				return 1/2/3/4;   //根据遍历的结果 返回不同的int
			}
		}

	3.数据持久层	------ 文件操作类 /  数据库操作类 / 配置文件操作类

		文件/配置文件：读  写
		数据库：	   增删改查

		FileOperator::Getvector()
		{
			// 1.打开文件

			// 2.读行，把内容存放在vector中

			// 3.关闭文件

			// 4.返回内容

		}


	层次直接的调用规则(向下调用)：

		UI  ---->  Logic  ------>  Data		OK

		UI  -------->Data				OK


	反之不允许，Data  -->  UI				Error
	好处：

			1.每个层次的类，都有明确的功能或者分工

			2.层次与层次之间调用不会发生混乱

				备注：C++开发一般是严谨类与类之间相互包含

			3.便于框架的扩展

				添加或删除功能的时候，工作量小，且相互直接
				基本不影响
		案例一：	Valid{};

				void CheckID();
				void CHeckXXX();
				//void CheckXXX();

		案例二：

				删除一个功能界面类的时候，业务逻辑类和数据持久类
				是不用做任何修改的



		

3.补充说明：

	有虚函数的类，它的析构函数也必须是虚函数


4.友员机制

	功    能:提供一种在类的外部访问类中所有成员的途径

	关键字：friend
	
	应用范围：函数（友员函数）   /  类（友员类）

	友员函数

	友员类

		1.不能反转

			B是A的朋友，但A不是B的朋友

		2.不能传递  exercise 001

			C是B的朋友，B是A的朋友，但C不是A的朋友

		3.不能继承  exercise 002

			Father是A的朋友，但Son不是A的朋友

	特	点：

		友员在一定程度是破坏了类的封装性的。

	应     用：

		在 运算符重载 中使用友员


5.运算符重载

	（1）运算符的工作原理：

		int i;
		int j;
		i+j;  ===>  运算符 +的实现，主要靠 加号的运算符函数

		a.默认的运算符函数，用户（程序员）是无法使用的。

	（2）为什么要引于 运算符重载的概念？

		class Balance  // 营业额
		{
			double m_money;
		}

		Balance  b1;
		Balance  b2;
		... ...

		double dResult = b1 + b2;

		C++中，对象是无法 直接  使用运算符运算的！
		即默认的运算符函数中的参数没有类类型
	
	（3）运算符函数

			函数名组成：	[operator] + [运算符符号]

	（4）运算符重载的方式：

			核心：访问类中的所有成员变量

		方式一：友员
		方式二：成员

	（5）运算符重载的注意事项：

		1.只能用友员或成员中的一种方式去重载

			否则，会出现 “重载有歧义”的错误	

		2.重载的时候，不要改变运算符的原有的意义

	（6）意义：提高编程效率


	（7）不同运算符的重载

		a.大部分运算符函数，都可以用 成员 或 友员重载

			+ - * /   > <   等等

		b.++  --的重载

			int 参数  ++ Or -- 在后

		c.数据类型的转换（成员）

			1.函数名：[operator] + [空格] + [数据类型]
			2.没有返回类型，但可以返回值
			3.只能用成员的方式重载

		d.默认提供的运算符重载函数（成员）

			 =  （赋值）

			 &  （取地址）

		e. << >> 输入输出运算符的重载（友员）

			1.只能用友员方式重载

				例如：cout 对应的ostream类是库提供，用户（程序员）
					无法为它添加operator<<()成员函数

			2.连续输入或输出，必须把全局IO对象的引用返回出来

		 f.不能重载的运算符

		成员访问运算符：    .   ->    不需要重载   a.show()   pa->show()
		取值运算符			*       不需要重载

		========以上的3中可能在不同编译器中是可以重载的

		========记住以下2个绝对不能重载的运算符即可

		域作用符号			::	不需要重载		A::show()
		条件运算符		      ？：    不是靠运算符函数实现的，且实现复杂
		
		
思考题：

	1. 一个空类中有哪些成员？	this 构造 拷贝构造 析构 =重载 &重载

	2.举例说说：
	   能用友员或成员实现重载的运算符：
	   只能有成员实现重载的运算符：
	   只能有友员实现重载的运算符：
	   不能重载的运算符：

home work 001:
	
	实现一个复数类

		由  实部 和 虚部  组成   例如：  3(实部) +  2*i(虚部)

	重载 + - * / 运算符即可  i*i = -1;

		复数的 *   / 运算可参考网上公式


home work 002:
	
	实现  XXX软件的登录功能：

			1.一个类或有继承关系的多个类 占用
				一个.h 和.cc 文件
				.h  文件包含->宏定义->类的声明   （禁止使用全局）
				.cc 静态成员变量的初始化 -->类成员函数实现的

			2.main.cc 只放  文件包含 和  main函数

			3.执行make,运行程序

		说明：数据持久层的类暂时不用实现


home work 003:

	门禁系统

		1.完成用户级别 设定的3个类

			必须在main函数中进行单元测试













